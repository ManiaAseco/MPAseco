/**
 *	Mode melee
 */

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"MeleeArena"
#Const	Version				"2013-01-24"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Interface.Script.txt" as Interface
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/ScoresTable.Script.txt" as ScoresTable

/* -------------------------------------- */
// Settings
/* -------------------------------------- */
#Setting S_TimeLimit	600 as _("Time limit")		///< Time limit on a map
#Setting S_PointLimit	25	as _("Points limit")	///< Points limit on a map

#Const C_NbBots			0	///< Number of bots

/* -------------------------------------- */
// Globales variables
/* -------------------------------------- */
declare Ident[]			G_SpawnsList;		///< Id of all the BlockSpawns of the map
declare Ident			G_LatestSpawnId;	///< Id of the last BlockSpawn used
declare Ident[Integer]	G_PrevScoreId;		///< Save the id of the first three scores

/* -------------------------------------- */
// Exstend
/* -------------------------------------- */

/* -------------------------------------- */
// Server start
/* -------------------------------------- */
***StartServer***
***
/* -------------------------------------- */
// Set mode options
UseClans = False;
G_PrevScoreId = [1 => NullId, 2 => NullId, 3 => NullId];

/* -------------------------------------- */
// Create the rules
declare ModeName = "Melee";
declare ModeRules = _("Free for all\n\n- Hit an opponent to score a point.\n- The player with the most points wins.");
SpawnScreen::CreateRules(ModeName, ModeRules);

SpawnScreen::CreateScores();
SpawnScreen::CreateMapInfo();
Interface::CreateRank();

/* -------------------------------------- */
// Create the scores table
ScoresTable::Load();
ScoresTable::SetColumnsWidth(2., 2., 3., 15., 2., 2., 0., 0., 0., 4., 5.);
ScoresTable::SetTableFormat(2, 6);
ScoresTable::Build();

/* -------------------------------------- */
// Create the UI layers
declare LayerAttached	= False;
declare LayerUpdated	= False;
declare LayerDestroyed	= False;
declare LayerMarkersId	= Layers::Create("Markers");
Layers::GetFromId(LayerMarkersId).Type = CUILayer::EUILayerType::Markers;
LayerAttached = Layers::Attach("Markers", NullId);
***

/* -------------------------------------- */
// Map start
/* -------------------------------------- */
***StartMap***
***	
XmlRpc.SendCallback("beginMap","");
SetNbFakePlayers(C_NbBots, 0);
G_SpawnsList.clear();
G_LatestSpawnId = NullId;
Score::MatchBegin();
Score::RoundBegin();

LayerUpdated = Layers::Update("Markers", "");
SM::SetupDefaultVisibility();

// Init scores
yield; ///< Allow the scores array to be sorted
foreach (Score in Scores) {
	declare Integer LastPoint for Score;
	LastPoint = 0;
}
declare LeadId = NullId;
if (Scores.existskey(0)) LeadId = Scores[0].User.Id;
declare CurrentPointLimit = S_PointLimit;

/* -------------------------------------- */
// New map message
UIManager.UIAll.SendNotice(
	"",
	CUIConfig::ENoticeLevel::MatchInfo, 
	Null, CUIConfig::EAvatarVariant::Default, 
	CUIConfig::EUISound::StartRound, 0
);

StartTime = Now;
EndTime = StartTime + (S_TimeLimit * 1000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
***

***OnNewPlayer***
***
ScoresTable::SetFooterStats(Player, TextLib::Compose(_("Points limit: %1"), TextLib::ToText(S_PointLimit)));
***

***OnNewSpectator***
***
ScoresTable::SetFooterStats(Spectator, TextLib::Compose(_("Points limit: %1"), TextLib::ToText(S_PointLimit)));
***

/* -------------------------------------- */
// Play loop
/* -------------------------------------- */
***PlayLoop***
***
foreach (Event, PendingEvents) {
	if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
		if (Event.Shooter == Event.Victim || Event.Shooter == Null) {
			Score::RemovePoints(Event.Victim, 1);
		}
		XmlRpc.SendCallback("playerDeath", Event.Victim.Login);	
		PassOn(Event);
	} else if (Event.Type == CSmModeEvent::EType::OnHit) {
		if (Event.Shooter == Event.Victim) {
			Discard(Event);
		} else {
			declare Points = Event.Damage / 100;
			// 1 bonus points for hitting the first player
			// if (Scores.existskey(0) && Scores[0].User.Id == Event.Victim.User.Id) Points += 1;
			Score::AddPoints(Event.Shooter, Points);
			Event.ShooterPoints = Points;
			XmlRpc.SendCallback("playerHit", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";"^Points);	
			if (Event.Shooter != Null && Event.Shooter.Score != Null) {						
				// Play sound and notice if someone is close to win
				declare LastPoint for Event.Shooter.Score = 0;
				declare Gap = S_PointLimit - Event.Shooter.Score.RoundPoints;
				if (Gap <= 3 && Gap > 0) {
					declare Variant = 3 - Gap;
					declare Msg = "";
					if (Gap > 1)
						Msg = TextLib::Compose(_("$<%1$> is %2 points from victory!"), Event.Shooter.Name, TextLib::ToText(Gap));
					else 
						Msg = TextLib::Compose(_("$<%1$> is 1 point from victory!"), Event.Shooter.Name);

					Message::SendBigMessage(
						Msg,
						3000,
						2,
						CUIConfig::EUISound::TieBreakPoint,
						Variant
					);
				} else if (Gap <= 0) {
					Message::SendBigMessage(
						TextLib::Compose(_("$<%1$> gets the final hit!"), Event.Shooter.Name),
						3000,
						3,
						CUIConfig::EUISound::VictoryPoint,
						0
					);
				} else {
					declare SoundGap = S_PointLimit / 5;
					if(SoundGap < 5) SoundGap = 5;
					if (Event.Shooter.Score.RoundPoints / SoundGap > LastPoint) {
						LastPoint = Event.Shooter.Score.RoundPoints / SoundGap;
						Message::SendBigMessage(
							Event.Shooter,
							TextLib::Compose(
								_("$666Score : $fff%1 / %2"), 
								TextLib::ToText(Event.Shooter.Score.RoundPoints), 
								TextLib::ToText(S_PointLimit)
							),
							3000,
							0,
							CUIConfig::EUISound::ScoreProgress,
							((Event.Shooter.Score.RoundPoints / SoundGap) - 1)
						);
					}
				}
			}
			PassOn(Event);
		}
	} else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {	
    XmlRpc.SendCallback("playerRespawn", Event.Player.Login);						
		Score::RemovePoints(Event.Player, 1);
		PassOn(Event);
	} else {
		PassOn(Event);
	}
}	

/* -------------------------------------- */
// Spawn players
foreach (Player in Players) {
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate) {
		MeleeSpawnPlayer(Player);
	}
}

/* -------------------------------------- */
// Play sound and notice if someone is taking the lead
if (Scores.existskey(0) && Scores[0].User.Id != LeadId) {
	LeadId = Scores[0].User.Id;
	Message::SendBigMessage(
		TextLib::Compose(
			_("$<%1$> takes the lead!"),
			Scores[0].User.Name
		), 									///< Message
		3000,								///< Duration
		1,									///< Priority
		CUIConfig::EUISound::PhaseChange,	///< Sound
		1									///< Sound variant
	);
}

/* -------------------------------------- */
// Update UI points limit
if (CurrentPointLimit != S_PointLimit) {
	CurrentPointLimit = S_PointLimit;
	foreach (Player in Players) ScoresTable::SetFooterStats(Player, TextLib::Compose(_("Points limit: %1"), TextLib::ToText(S_PointLimit)));
	foreach (Spectator in Spectators) ScoresTable::SetFooterStats(Spectator, TextLib::Compose(_("Points limit: %1"), TextLib::ToText(S_PointLimit)));
}

Message::Loop();
UpdateMarkers();

/* -------------------------------------- */
// victory conditions
declare IsMatchOver = False;
if (Now > EndTime) IsMatchOver = True;
foreach (Player in Players) {
	if (Player.Score != Null && Player.Score.RoundPoints >= S_PointLimit) IsMatchOver = True;
}

if (IsMatchOver) MB_StopMap = True;
***

/* -------------------------------------- */
// Map end
/* -------------------------------------- */
***EndMap***
***
XmlRpc.SendCallback("endMap",GetRankings());
EndTime = -1;
Score::RoundEnd();
Score::MatchEnd(True);
LayerUpdated = Layers::Update("Markers", "");

/* -------------------------------------- */
// End match sequence
declare CUser Winner <=> Null;
declare MaxPoints = 0;
foreach (Score in Scores) {
	if (Score.Points > MaxPoints) {
		MaxPoints = Score.Points;
		Winner <=> Score.User;
	} else if (Score.Points == MaxPoints) {
		Winner <=> Null;
	}
}
foreach (Player in Players) {
	if (Player.User != Winner) UnspawnPlayer(Player);
	Interface::UpdatePosition(Player);
}

sleep(1000);
Message::CleanBigMessages();
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
UIManager.UIAll.BigMessageSoundVariant = 0;
if (Winner != Null) {
	UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the match!"), Winner.Name);
} else {
	UIManager.UIAll.BigMessage = _("|Match|Draw");
}
sleep(2000);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
sleep(5000);

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
wait(UIManager.UIAll.UISequenceIsCompleted);

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";
***

/* -------------------------------------- */
// Server end
/* -------------------------------------- */
***EndServer***
***
LayerDestroyed = Layers::Destroy("Info");
ScoresTable::Unload();
Interface::DestroyRank();
SpawnScreen::DestroyRules();
SpawnScreen::DestroyScores();
SpawnScreen::DestroyMapInfo();
***

/* -------------------------------------- */
// Functions
/* -------------------------------------- */

/* ------------------------------------- */
/** Spawn a player
 *
 * @param	_Player		The player to spawn
 */
Void MeleeSpawnPlayer(CSmPlayer _Player) {
	if (G_SpawnsList.count == 0) {
		foreach (BlockSpawn in BlockSpawns) G_SpawnsList.add(BlockSpawn.Id);
	}
	
	declare SpawnId = NullId;
	while (True) {
		SpawnId = G_SpawnsList[MathLib::Rand(0, G_SpawnsList.count - 1)];
		if (SpawnId != G_LatestSpawnId) break;
		if (G_SpawnsList.count == 1) break;
	}
	G_LatestSpawnId = SpawnId;
	SM::SpawnPlayer(_Player, 0, BlockSpawns[SpawnId]);
	declare Removed = G_SpawnsList.remove(SpawnId);
}

/* ------------------------------------- */
/** Update the markers above the players
 *
 *	@return		The markers manialink
 */
Text UpdateLayerMarkers() {
	declare MarkersML = "";
	
	/*if (Scores.count >= 1) MarkersML ^= """<frame id="Marker_First"><quad posn="0 0 3" sizen="10 10" halign="center" style="Icons64x64_1" substyle="First"/></frame>""";
	if (Scores.count >= 2) MarkersML ^= """<frame id="Marker_Second"><quad posn="0 0 2" sizen="10 10" halign="center" style="Icons64x64_1" substyle="Second"/></frame>""";
	if (Scores.count >= 3) MarkersML ^= """<frame id="Marker_Third"><quad posn="0 0 1" sizen="10 10" halign="center" style="Icons64x64_1" substyle="Third"/></frame>""";*/
	
	return MarkersML;
}

/* ------------------------------------- */
/// Update the markers when necessary
Void UpdateMarkers() {
	declare I = 0;
	declare ScoreUpdated = False;
	
	foreach (Score in Scores) {
		I += 1;
		if (G_PrevScoreId[I] != Score.Id) {
			G_PrevScoreId[I] = Score.Id;
			ScoreUpdated = True;
		}
		if (I >= 3) break;
	}
	
	if (ScoreUpdated) {
		declare LayerUpdated = Layers::Update("Markers", UpdateLayerMarkers());
		UIManager.UIAll.Hud3dMarkers = "";
		I = 0;
		foreach (Score in Scores) {
			I += 1;
			declare MarkerId = "First";
			if (I == 2) MarkerId = "Second";
			else if (I == 3) MarkerId = "Third";
			UIManager.UIAll.Hud3dMarkers ^= """<marker playerlogin="{{{Score.User.Login}}}" manialinkframeid="Marker_{{{MarkerId}}}" visibility="WhenInMiddleOfScreen" />""";
			if (I >= 3) break;
		}
	}
}

// Get the current rankings for xmlrpc callbacks
Text GetRankings() {
	declare PlayerList = "";
	foreach (Score in Scores) {
		PlayerList ^= Score.User.Login^":"^Score.Points^";";
	}
	return PlayerList;
}
