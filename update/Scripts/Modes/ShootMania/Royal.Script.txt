/**
 *	Mode Royal
 */

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const	CompatibleMapTypes	"RoyalArena"
#Const	Version				"2012-12-20"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Top.Script.txt" as Top
#Include "Libs/Nadeo/Layers.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/Rules.Script.txt" as Rules

/* ------------------------------------- */
// Settings
/* ------------------------------------- */
#Setting S_MapPointsLimit			200		as _("Points to win a map")
#Setting S_OffZoneActivationTime	4		as _("OffZone activation duration")
#Setting S_OffZoneAutoStartTime		90		as _("Time before auto activation of the OffZone")
#Setting S_OffZoneTimeLimit			50		as _("OffZone shrink duration")
#Setting S_OffZoneMaxSpeed			1.25	as _("Maximum speed multiplier for the OffZone")
#Setting S_EndRoundTimeLimit		60		as _("Time limit after the OffZone is completly shrunk")
#Setting S_SpawnInterval			5		as _("Time between each wave of spawns")
#Setting S_UseEarlyRespawn			True	as _("Allow early respawn")
#Setting S_EndMapChatTime			20		as _("End map chat time")

#Const C_OffZoneMinRadius		16.		///< Minimum size of the OffZone at the end
#Const C_OffZoneDefaultRadius	300.	///< Starting radius of the OffZone
#Const C_ArmorMax				200		///< Maximum number of armor at spawn
#Const C_ArmorRespawn			100		///< Armor after an early respawn
#Const C_RandomEarlyRespawn		True	///< Spawn at a random point when early respawning
#Const C_DamageMax				100		///< Not possible to inflict more damage with one hit
#Const C_CaptureSpeedBonus		1.		///< Default capture speed bonus
#Const C_GaugeMultiplier		1000	///< Gauge.Max multiplier used for exact capture speed calculation
#Const C_AllowDrawMap			False	///< Allow a map to end in a tie
#Const C_AllowDoubleCapture		False	///< Allow the pole to be captured a second time

#Const C_ScoresTableWidth		160.	///< Width of the scores table UI
#Const C_ScoresTableScale		1.		///< Scale of the scores table UI
#Const C_ScoresTableNbPlayers	16		///< Number of players in the scores table
#Const C_ScoresTablePlayerHeight 6.		///< Height of a line for a player

#Const C_ScoreHit		1	///< Index for hit points
#Const C_ScoreSurvival	2	///< Index for survival points
#Const C_ScorePole		3	///< Index for pole points

#Const C_TabMenu	1
#Const C_AltMenu	2

#Const C_UI_Colors [
	"BG" => "3329",
	"Separator" => "999f",
	"Text" => "ddcf"
]

#Const C_NbBots	0	///< Number of bots for debug

/* ------------------------------------- */
// Globales variables
/* ------------------------------------- */
declare Integer			G_SurvivalScore;	///< The current score for survival
declare Ident[Integer]	G_LastEliminations;	///< Save the last 2 eliminated players

/* -------------------------------------- */
// Extend
/* -------------------------------------- */

***InitServer***
***
declare LayerAttached	= False;
declare LayerDetached	= False;
declare LayerUpdated	= False;
declare LayerDestroyed	= False;
declare AllowDoubleCapture = C_AllowDoubleCapture;
declare OffZoneMaxSpeedTime = 20; ///<Duration of capture to reach maximum speed
***


***StartServer***
***
/* -------------------------------------- */
// Set mode options and tops
MB_UseSectionRound	= True;
UseClans			= False;
Top::AddTop("Pole", 5);
Top::AddTop("Hit", 5);
Top::AddTop("Survival", 5);
Top::AddTop("Round", 5);

/* ------------------------------------- */
// Create Rules
declare ModeName = "Royal";
declare ModeRules = TextLib::Compose(_("Free for all\n- Survive as long as possible to score a maximum of points.\n- Bonus points are awarded for the pole capture and for each player hit.\n- If the pole is captured then the playing area will start to shrink. If a player leaves this area he is eliminated.\n- The first player to reach %1 points wins."), TextLib::ToText(S_MapPointsLimit));
Rules::Create(ModeName, ModeRules);
	
/* ------------------------------------- */
// Init UI
declare LayerSpawnQueueId		= Layers::Create("SpawnQueue");
declare LayerTabScoresTableId	= Layers::Create("TabScoresTable", CreateLayerScoresTable(C_TabMenu));
declare LayerAltScoresTableId	= Layers::Create("AltScoresTable", CreateLayerScoresTable(C_AltMenu));
declare LayerInfoId			 	= Layers::Create("Info", CreateLayerInfo());
declare LayerTopsId				= Layers::Create("Tops");
declare LayerScoresInSpawnId	= Layers::Create("ScoresInSpawn");

Layers::GetFromId(LayerTabScoresTableId).Type = CUILayer::EUILayerType::ScoresTable;
Layers::GetFromId(LayerAltScoresTableId).Type = CUILayer::EUILayerType::AltMenu;
Layers::GetFromId(LayerScoresInSpawnId).Type = CUILayer::EUILayerType::ScreenIn3d;

LayerAttached = Layers::Attach("TabScoresTable", NullId);
LayerAttached = Layers::Attach("AltScoresTable", NullId);
LayerAttached = Layers::Attach("ScoresInSpawn", NullId);

UIManager.UIAll.AltMenuNoCustomScores = True;
UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchInfo;
***


***InitMap***
***
declare MapWinnerPlayer			= NullId;	///< User Id of the map winner
declare BlockSpawnsPriorities	= [1=>CSmBlockSpawn[], 2=>CSmBlockSpawn[], 3=>CSmBlockSpawn[]];
declare Pole					<=> SM::GetPole("Goal", 0);	///< The pole used as the OffZone center
assert(Pole != Null);
***


***StartMap***
***
SetNbFakePlayers(C_NbBots, 0);
Score::MatchBegin();
Top::MatchBegin();
Top::RoundBegin();	///< Want global tops for the match
XmlRpc.SendCallback("beginMap",MapName);

/* ------------------------------------- */
// Init players
foreach (Player in Players) {
	declare SpawnOrder for Player = 0;
	SpawnOrder = 0;
}

/* ------------------------------------- */
// Init map scores
foreach (Score in Scores) {
	declare MapHit for Score = 0;		///< Points given by the number of hit
	declare MapSurvival for Score = 0;	///< Points for survival
	declare MapPole for Score = 0;		///< Points for capturing the pole
	
	MapHit = 0;
	MapSurvival = 0;
	MapPole = 0;
}

/* ------------------------------------- */
// Add a marker above the pole
UIManager.UIAll.Hud3dMarkers = """
<marker icon="PointA" pos="{{{ Pole.Position.X }}} {{{ Pole.Position.Y + 25 }}} {{{ Pole.Position.Z }}}" />
""";
***


***InitRound***
***
declare RoundWinnerPlayer	= NullId;					///< User Id of the round winner
declare LastSpawnTime		= -S_SpawnInterval * 1000;	///< Last time a batch of player was spawned
declare EarlyRespawnAllowed	= True;						///< Check if the players can early respawn
declare GameplaySequence	= 0;						///< Current gameplay sequence
declare PlayersSpawnQueue	= Integer[Ident];			///< Players waiting to be spawned: Order[Player.Id]
declare PlayersSpawnedNb	= 0;						///< Number of players spawned for this round
declare PlayersAlive		= Ident[Ident];				///< List of alive players: Player.Score.Id[Player.Id];
declare FirstElimId			= NullId;					///< Id of the first eliminated user
declare UpdateLayerScoresTable = False;					///< The scores table UI need an update
declare OffZoneStartingRadiusSpeed = 1.;				///< Starting speed of the OffZone
declare EarlyRespawnBlockPool = CSmBlockSpawn[];		///< Pool of available spawns for early respawn
***


***StartRound***
***
Score::RoundBegin();
XmlRpc.SendCallback("beginRound",fixGetRankings());
Message::CleanAllMessages();

/* ------------------------------------- */
// Init scores
foreach (Score in Scores) {
	declare HitNb for Score = 0;	///< Number of hit
	declare Hit for Score = 0;		///< Points given by the number of hit
	declare Survival for Score = 0;	///< Points for survival
	declare Pole for Score = 0;		///< Points for capturing the pole
	declare EliminatedBy for Score = "";	///< Login of th eliminator
	
	HitNb = 0;
	Hit = 0;
	Survival = 0;
	Pole = 0;
	EliminatedBy = "";
}
G_SurvivalScore = 1;
G_LastEliminations = [1 => NullId, 2 => NullId];

/* ------------------------------------- */
// Init pole
Pole.Gauge.Clan = 0;
Pole.Gauge.Value = 0;
Pole.Gauge.Speed = 0;
Pole.Gauge.Max = (S_OffZoneActivationTime * 1000) * C_GaugeMultiplier;
if (S_OffZoneActivationTime <= 0) Pole.Gauge.Max = 10;

/* ------------------------------------- */
// Init offzone
OffZoneRadius = -1.;
OffZoneRadiusSpeed = 0.;
OffZoneCenterBlockId = Pole.Id;

/* ------------------------------------- */
// Wait until the round starting conditions are met
WaitForPlayers();

/* ------------------------------------- */
// Init spawn queue
foreach (Player in Players) {
	declare SpawnOrder for Player = 0;
	PlayersSpawnQueue[Player.Id] = SpawnOrder;
	SpawnOrder = 0;
}
PlayersSpawnQueue = PlayersSpawnQueue.sort();

/* ------------------------------------- */
// Update UI
LayerAttached = Layers::Attach("SpawnQueue", NullId);
LayerUpdated = Layers::Update("ScoresInSpawn", UpdateLayerScoresInSpawn());

SM::SetupDefaultVisibility();
StartTime = Now;
EndTime = -1;
UIManager.UIAll.CountdownEndTime = -1;

UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Silence;
UIManager.UIAll.SendNotice(
	"", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default,  CUIConfig::EUISound::StartRound, 0
);
UIManager.UIAll.BigMessage = _("Spawning players...");
***


***OnNewPlayer***
***
declare CanEarlyRespawn for Player = False;
declare LastBlockSpawn for Player <=> CSmBlockSpawn;
CanEarlyRespawn = False;
LastBlockSpawn <=> Null;

// Player join during the round
if (Now > StartTime + 10) UpdateLayerScoresTable = True;
***


***OnNewSpectator***
***
declare CanEarlyRespawn for Spectator = False;
declare LastBlockSpawn for Spectator <=> CSmBlockSpawn;
CanEarlyRespawn = False;
LastBlockSpawn <=> Null;

// Player join during the round
if (Now > StartTime + 10) UpdateLayerScoresTable = True;
***


***PlayLoop***
***
Message::Loop();

/* ------------------------------------- */
/* Update UI
 * Delayed by 1 frame to take events into account
 */
if (UpdateLayerScoresTable) {
	UpdateLayerScoresTable();
	UpdateLayerScoresTable = False;
}

switch (GameplaySequence) {
	/* ------------------------------------- */
	// Spawning players
	case 0: {		
		if (LastSpawnTime + (S_SpawnInterval * 1000) <= Now) {
			LastSpawnTime = Now;
			UIManager.UIAll.CountdownEndTime =  LastSpawnTime + (S_SpawnInterval * 1000);
			
			declare SpawnQueueCount = 0;
			/* ------------------------------------- */
			// Init spawn priority list
			foreach (BlockSpawn in BlockSpawns) {
				if (BlockSpawn.Order <= 1)		BlockSpawnsPriorities[1].add(BlockSpawn);
				else if (BlockSpawn.Order == 2)	BlockSpawnsPriorities[2].add(BlockSpawn);
				else if (BlockSpawn.Order >= 3)	BlockSpawnsPriorities[3].add(BlockSpawn);
			}
		
			for (I, 1, 3) {
				//foreach (BlockSpawn in BlockSpawnsPriorities[I]) {
				while (BlockSpawnsPriorities[I].count > 0) {
					declare BlockSpawn <=> BlockSpawnsPriorities[I][MathLib::Rand(0, BlockSpawnsPriorities[I].count - 1)];
					declare Removed = BlockSpawnsPriorities[I].remove(BlockSpawn);
					/* ------------------------------------- */
					// Spawning players
					declare ToRemove = Ident[];
					foreach (PlayerId => SpawnOrder in PlayersSpawnQueue) {
						ToRemove.add(PlayerId);
						if (
							Players.existskey(PlayerId) 
							&& Players[PlayerId].SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned
						) {
							declare Player <=> Players[PlayerId];
							declare CanEarlyRespawn for Player = False;
							declare LastBlockSpawn for Player <=> CSmBlockSpawn;
							declare ReloadSpeedBonus for Player.User = 1.;
							declare CaptureSpeedBonus for Player = 1.;
							CanEarlyRespawn = False;
							LastBlockSpawn <=> BlockSpawn;
							Player.AmmoGain = ReloadSpeedBonus;
							Player.ArmorMax = C_ArmorMax;
							CaptureSpeedBonus = C_CaptureSpeedBonus;
							
							+++OnPlayerSpawn+++
							SM::SpawnPlayer(Player, 0, Player.ArmorMax, BlockSpawn, Now);
							CanEarlyRespawn = True;
							PlayersSpawnedNb += 1;
							if (Player.Score != Null) {
								PlayersAlive[Player.Id] = Player.Score.Id;
								// Start with one survival point
								UpdatePlayerScores(Player, C_ScoreSurvival, 1);
								XmlRpc.SendCallback("playerSurvival", Player.Login);	
								Top::IncrementPlayerPoints("Survival", Player, 1);
							} else PlayersAlive[Player.Id] = NullId;
							break;
						}
					}
					foreach (PlayerId in ToRemove) {
						declare Removed = PlayersSpawnQueue.removekey(PlayerId);
					}
					SpawnQueueCount = PlayersSpawnQueue.count;
				}
			}
			
			UpdateLayerScoresTable = True;
			LayerUpdated = Layers::Update("SpawnQueue", UpdateLayerSpawnQueue(PlayersSpawnQueue));
			if (SpawnQueueCount <= 0) {
				GameplaySequence = 1;
			}
		}
	}
	/* ------------------------------------- */
	// Launch the OffZone auto activation countdown
	case 1: {
		declare OffZoneAutoStartTime = S_OffZoneAutoStartTime * 1000;
		if (OffZoneAutoStartTime < 0) OffZoneAutoStartTime = 0;
		UIManager.UIAll.CountdownEndTime = Now + OffZoneAutoStartTime;
		UIManager.UIAll.BigMessage = "";
		Message::SendStatusMessage(
			_("The pole can now be captured."), OffZoneAutoStartTime, 1, CUIConfig::EUISound::PhaseChange, 0
		);
		LayerDetached = Layers::Detach("SpawnQueue", NullId);
		LayerAttached = Layers::Attach("Info", NullId);
		UpdateLayerInfo(PlayersNbAlive);
		GameplaySequence = 2;
	}
	/* ------------------------------------- */
	// Waiting for the pole capture/OffZone activation (automatic or manual)
	case 2: {
		// Auto activation of the OffZone
		if (UIManager.UIAll.CountdownEndTime <= Now) {
			Pole.Gauge.Speed = Pole.Gauge.Max;
			Pole.Gauge.Value = Pole.Gauge.Max + 1;
		}
		// Manual activation of the OffZone
		else {
			if (Pole.Sector.PlayersIds.count > 0) {
				declare CaptureSpeed = 1.;
				declare BonusMax = 0.;
				foreach (PlayerId in Pole.Sector.PlayersIds) {
					declare CaptureSpeedBonus for Players[PlayerId] = 1.;
					if (CaptureSpeedBonus > BonusMax) BonusMax = CaptureSpeedBonus;
				}
				CaptureSpeed = BonusMax * C_GaugeMultiplier;

				Pole.Gauge.Speed = MathLib::NearestInteger(CaptureSpeed);
			} else Pole.Gauge.Speed = 0;
		}
	}
	/* ------------------------------------- */
	// Offzone shrinking
	case 3: {
		if (AllowDoubleCapture) {
			if (!Pole.Captured && Pole.Sector.PlayersIds.count > 0) {
				declare CaptureSpeed = 1.;
				declare BonusMax = 0.;
				foreach (PlayerId in Pole.Sector.PlayersIds) {
					declare CaptureSpeedBonus for Players[PlayerId] = 1.;
					if (CaptureSpeedBonus > BonusMax) BonusMax = CaptureSpeedBonus;
				}
				CaptureSpeed = BonusMax * C_GaugeMultiplier;
				
				Pole.Gauge.Speed = MathLib::NearestInteger(CaptureSpeed);
				
				declare RadiusSpeedBonus = (1 + ((S_OffZoneMaxSpeed - 1.) * (MathLib::ToReal(Pole.Gauge.Value) / MathLib::ToReal(Pole.Gauge.Max))));
				OffZoneRadiusSpeed = OffZoneStartingRadiusSpeed * RadiusSpeedBonus;
				UIManager.UIAll.StatusMessage = TextLib::Compose(
					_("OffZone speed: %1%%"), TextLib::ToText(MathLib::NearestInteger(RadiusSpeedBonus * 100))
				);
			} else Pole.Gauge.Speed = 0;
		}
		
		if (OffZoneRadius <= C_OffZoneMinRadius) {
			OffZoneRadiusSpeed = 0.;
			OffZoneRadius = C_OffZoneMinRadius;
			GameplaySequence = 4;
		}
	}
	/* ------------------------------------- */
	// Revert pole gauge
	case 4: {
		declare EndRoundTimeLimit = S_EndRoundTimeLimit * 1000;
		if (EndRoundTimeLimit < 0) EndRoundTimeLimit = 0;
		UIManager.UIAll.CountdownEndTime = -1;
		EndTime = Now + EndRoundTimeLimit;
		if (Pole.Gauge.Value == 0) {
			Pole.Gauge.Max = 0;
			Pole.Gauge.Value = 0;
			Pole.Gauge.Speed = 0;
		} else {
			Pole.Gauge.Max = MathLib::NearestInteger((Pole.Gauge.Max / (Pole.Gauge.Value *1.)) * (EndTime - Now));
			Pole.Gauge.Value = EndTime - Now;
			Pole.Gauge.Speed = -1;
		}
		GameplaySequence = 10;
	}
}

/* ------------------------------------- */
// Early respawn
if (S_UseEarlyRespawn && EarlyRespawnAllowed) {
	foreach (Player in Players) {
		declare CanEarlyRespawn for Player = False;
		if (CanEarlyRespawn && Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
			declare RandomBlockSpawn <=> CSmBlockSpawn;
			if (EarlyRespawnBlockPool.count <= 0) {
				EarlyRespawnBlockPool.clear();
				foreach (BlockSpawn in BlockSpawns) {
					EarlyRespawnBlockPool.add(BlockSpawn);
				}
			}
			RandomBlockSpawn <=> EarlyRespawnBlockPool[MathLib::Rand(0, EarlyRespawnBlockPool.count - 1)];
			declare Removed = EarlyRespawnBlockPool.remove(RandomBlockSpawn);

			declare LastBlockSpawn for Player <=> CSmBlockSpawn;
			if (LastBlockSpawn == Null || C_RandomEarlyRespawn) {
				LastBlockSpawn <=> BlockSpawns[MathLib::Rand(0, BlockSpawns.count - 1)];
			}
			
			declare ReloadSpeedBonus for Player.User = 1.;
			declare CaptureSpeedBonus for Player = 1.;
			Player.AmmoGain = ReloadSpeedBonus;
			CaptureSpeedBonus = C_CaptureSpeedBonus;
			
			+++OnPlayerSpawn+++
			Player.ArmorMax = C_ArmorRespawn;
			SM::SpawnPlayer(Player, 0, Player.ArmorMax, LastBlockSpawn, Now);
		}
	}
}

foreach (Event in PendingEvents) {
	/* ------------------------------------- */
	// On hit
	if (Event.Type == CSmModeEvent::EType::OnHit) {
		if (Event.Shooter != Null && Event.Victim != Null) {
			/* ------------------------------------- */
			// Ceiling the damages at 100
			Event.Damage = C_DamageMax;
			
			if (Event.Victim == Event.Shooter) Discard(Event);
			else {
				/* ------------------------------------- */
				// Update Hit score
				if (Event.Shooter.Score != Null) {
					declare HitNb for Event.Shooter.Score = 0;
					declare LostArmor = Event.Damage;
					if (Event.Damage > Event.Victim.Armor) LostArmor = Event.Victim.Armor;
					declare Points = 0;
					
					for (I, 1, LostArmor / 100) {
						Points += (HitNb / 2) + 1;
						HitNb += 1;
					}
					
					UpdatePlayerScores(Event.Shooter, C_ScoreHit, Points);
					Event.ShooterPoints = Points;
					Top::IncrementPlayerPoints("Hit", Event.Shooter, Points);
					XmlRpc.SendCallback("playerHit", "Victim:"^Event.Victim.Login^";Shooter:"^Event.Shooter.Login^";"^Points);	
				}
				
				UpdateLayerScoresTable = True;
				PassOn(Event);
			}
		} else {
			UpdateLayerScoresTable = True;
			PassOn(Event);
		}
	} 
	/* ------------------------------------- */
	// On armor empty
	else if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
		if (Event.Victim != Null && !EarlyRespawnAllowed) {
			declare Removed = PlayersAlive.removekey(Event.Victim.Id);
			UpdateSurvivalScore(PlayersAlive);
			XmlRpc.SendCallback("playerDeath", Event.Victim.Login);				
			UpdateLayerScoresTable = True;
			UpdateLastEliminations(Event.Victim.Score);
			UpdateLayerInfo(PlayersNbAlive - 1);
			declare SpawnOrder for Event.Victim = 0;
			SpawnOrder = Now;
			if (FirstElimId == NullId) {
				if (Event.Shooter != Null) {
					FirstElimId = Event.Shooter.User.Id;
					DisplayFirstElimMessage(FirstElimId, False);
				} else {
					FirstElimId = Event.Victim.User.Id;
					DisplayFirstElimMessage(FirstElimId, True);
				}
			}
			
			if (Event.Victim.Score != Null) {
				declare EliminatedBy for Event.Victim.Score = "";
				if (Event.Shooter != Null) EliminatedBy = Event.Shooter.Login;
				else EliminatedBy = "*";
			}
			
			// Play a sound on the last 5 players eliminations
			if (PlayersNbAlive <= 5) {
				declare Variant = 5 - PlayersNbAlive;
				UIManager.UIAll.SendNotice(
					"", 
					CUIConfig::ENoticeLevel::MatchInfo, Null, 
					CUIConfig::EAvatarVariant::Default, 
					CUIConfig::EUISound::TieBreakPoint, Variant
				);
			}
		}
		PassOn(Event);
	} 
	/* ------------------------------------- */
	// On capture
	else if(Event.Type == CSmModeEvent::EType::OnCapture) {		
		Message::CleanAllMessages();
		
		declare OffZoneTimeLimit = S_OffZoneTimeLimit  * 1000;
		if (OffZoneTimeLimit <= 0) OffZoneTimeLimit = 10;
					
		/* ------------------------------------- */
		// Update Pole score
		if (Event.BlockPole.Sector.PlayersIds.count > 0) {
			declare Points = PlayersSpawnedNb / Event.BlockPole.Sector.PlayersIds.count;
			foreach (PlayerId in Event.BlockPole.Sector.PlayersIds) {
				if (Players.existskey(PlayerId) && Players[PlayerId].Score != Null) {
					declare Player <=> Players[PlayerId];
					UpdatePlayerScores(Player, C_ScorePole, Points);
				 					XmlRpc.SendCallback("poleCapture", Players[PlayerId].Login); 
        	Top::IncrementPlayerPoints("Pole", Player, Points);
					
					// Use notices to display several messages one after the other
					UIManager.UIAll.SendNotice(
						TextLib::Compose(_("$<%1$> captured the pole."), Player.Name), 
						CUIConfig::ENoticeLevel::MatchInfo, Null, 
						CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::StartRound, 0
					);
				}
			}
			declare Message = "";
			if (GameplaySequence == 2) {
				Message = _("OffZone activated.");
				if (AllowDoubleCapture) {
					Message::SendStatusMessage(
						_("Stay near the pole to speed up the OffZone"), 2000, 1, CUIConfig::EUISound::StartRound, 0
					);
				}
			}
			else if (GameplaySequence == 3) {
				UIManager.UIAll.StatusMessage = "";
				Message = TextLib::Compose(
					_("OffZone speed: %1%%"), TextLib::ToText(MathLib::NearestInteger(S_OffZoneMaxSpeed * 100))
				);
			}
			UIManager.UIAll.SendNotice(
				Message, 
				CUIConfig::ENoticeLevel::MatchInfo, Null, 
				CUIConfig::EAvatarVariant::Default, 
				CUIConfig::EUISound::StartRound, 0
			);
		} else {
			declare Message = "";
			if (GameplaySequence == 2) {
				Message = _("Pole captured and OffZone activated.");
				if (AllowDoubleCapture) {
					Message::SendStatusMessage(
						_("The pole can be captured again."), OffZoneTimeLimit, 1, CUIConfig::EUISound::StartRound, 0
					);
				}
			}
			else if (GameplaySequence == 3) {
				Message = TextLib::Compose(
					_("OffZone speed: %1%%"), TextLib::ToText(MathLib::NearestInteger(S_OffZoneMaxSpeed * 100))
				);
			}
			Message::SendBigMessage(
				Message, 3000, 2, CUIConfig::EUISound::StartRound, 0
			);
		}
		
		/* ------------------------------------- */
		// Active OffZone
		if (GameplaySequence == 2) {			
			OffZoneRadius = C_OffZoneDefaultRadius;
			OffZoneStartingRadiusSpeed = (C_OffZoneDefaultRadius - C_OffZoneMinRadius) / (OffZoneTimeLimit/1000);
			OffZoneRadiusSpeed = OffZoneStartingRadiusSpeed;
			Event.BlockPole.Gauge.Speed = 0;
			
			if (AllowDoubleCapture) {
				declare Local_OffZoneMaxSpeedTime = (OffZoneMaxSpeedTime * 1000);
				if (OffZoneMaxSpeedTime <= 0) Local_OffZoneMaxSpeedTime = 10;
				Event.BlockPole.Gauge.Max = (Local_OffZoneMaxSpeedTime * C_GaugeMultiplier);
				Event.BlockPole.Gauge.Value = 0;
			}
			
			UIManager.UIAll.CountdownEndTime = -1;
			GameplaySequence = 3;
			
			/* ------------------------------------- */
			// Disable early respawn for all players
			EarlyRespawnAllowed = False;
		}
		/* ------------------------------------- */
		// Speed up OffZone
		else if (GameplaySequence == 3) {
			OffZoneRadiusSpeed = OffZoneStartingRadiusSpeed * S_OffZoneMaxSpeed;
		}
		
		UpdateLayerScoresTable = True;
		PassOn(Event);
	} 
	/* ------------------------------------- */
	// On player requests respawn
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
		if (Event.Player != Null && !EarlyRespawnAllowed) {
			declare Removed = PlayersAlive.removekey(Event.Player.Id);
			 XmlRpc.SendCallback("playerRespawn", Event.Player.Login);
      UpdateSurvivalScore(PlayersAlive);
			UpdateLayerScoresTable = True;
			UpdateLastEliminations(Event.Player.Score);
			UpdateLayerInfo(PlayersNbAlive - 1);
			
			declare SpawnOrder for Event.Player = 0;
			SpawnOrder = Now;
			if (!EarlyRespawnAllowed && FirstElimId == NullId) {
				FirstElimId = Event.Player.User.Id;
				DisplayFirstElimMessage(FirstElimId, True);
			}
		}
		PassOn(Event);
	} 
	/* ------------------------------------- */
	// Other cases
	else {
		PassOn(Event);
	}
}

/* ------------------------------------- */
// On Player disconnection
declare ToRemove = Ident[];
foreach (PlayerId => ScoreId in PlayersAlive) {
	if (!Players.existskey(PlayerId)) {
		ToRemove.add(PlayerId);
		if (Scores.existskey(ScoreId)) {
			declare Score <=> Scores[ScoreId];
			UpdateLastEliminations(Score);
			UpdateLayerInfo(PlayersNbAlive);
		
			if (!EarlyRespawnAllowed && FirstElimId == NullId) {
				FirstElimId = Score.User.Id;
				DisplayFirstElimMessage(FirstElimId, True);
			}
			declare EliminatedBy for Score = "";
			EliminatedBy = "*";
		} else UpdateLastEliminations(Null);
	}
}
foreach (PlayerId in ToRemove) {
	declare Removed = PlayersAlive.removekey(PlayerId);
	UpdateSurvivalScore(PlayersAlive);
	UpdateLayerScoresTable = True;
}
/* ------------------------------------- */
// Round end conditions
declare TimeLimitReached = (EndTime > 0 && EndTime <= Now);
declare AllEliminated = False;
if (
	!TimeLimitReached && GameplaySequence > 0
	&& (
		(PlayersNbAlive <= 1 && PlayersSpawnedNb != 1)
		|| (PlayersNbAlive <= 0 && PlayersSpawnedNb == 1) 
	)
) { 
	AllEliminated = True; 
	foreach (Player in Players) {
		if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
			RoundWinnerPlayer = Player.User.Id;
			
			declare Removed = PlayersAlive.removekey(Player.Id);
			UpdateSurvivalScore(PlayersAlive);
			UpdateLastEliminations(Player.Score);
			declare SpawnOrder for Player = 0;
			SpawnOrder = Now + 1;
		}
	}
}

if (TimeLimitReached || AllEliminated) {
	MB_StopRound = True;
}

XmlRpc.SendCallback("endRound",fixGetRankings());

***
***EndRound***
***
LayerDetached = Layers::Detach("SpawnQueue", NullId);
LayerDetached = Layers::Detach("Info", NullId);
Message::CleanAllMessages();
UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";
OffZoneRadiusSpeed = 0.;
Pole.Gauge.Speed = 0;

/* ------------------------------------- */
// Bonus points for last two survivors
declare ScoreToPlayer = Ident[Ident];
foreach (Player in Players) { 
	if (Player.Score != Null) ScoreToPlayer[Player.Score.Id] = Player.Id;
	if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
		+++EndRoundAlivePlayer+++
	}
}
foreach (Rank => ScoreId in G_LastEliminations) {	
	declare Points = 0;
	if (Rank == 1) {
		Points = PlayersSpawnedNb;
	} else if (Rank == 2) {
		Points = PlayersSpawnedNb / 2;
	}
	if (ScoreId != NullId && Scores.existskey(ScoreId)) {
		declare Score <=> Scores[ScoreId];
		if (ScoreToPlayer.existskey(ScoreId) && Players.existskey(ScoreToPlayer[ScoreId])) {
			UpdatePlayerScores(Players[ScoreToPlayer[ScoreId]], C_ScoreSurvival, Points);
			Top::IncrementPlayerPoints("Survival", Players[ScoreToPlayer[ScoreId]], Points);
		}
	}
}

foreach (Score in Scores) {	
	/* ------------------------------------- */
	// Balance players reload speed
	declare HitNb for Score = 0;
	declare ReloadSpeedBonus for Score.User = 1.;
	if (ReloadSpeedBonus < 1.3 && HitNb <= 1) ReloadSpeedBonus += .1;
	else if (HitNb > 1) ReloadSpeedBonus = 1.;

	/* ------------------------------------- */
	// Update map score
	declare MapHit for Score = 0;
	declare MapSurvival for Score = 0;
	declare MapPole for Score = 0;
	declare Hit for Score = 0;
	declare Survival for Score = 0;
	declare Pole for Score = 0;
	declare EliminatedBy for Score = "";
	
	MapHit += Hit;
	MapSurvival += Survival;
	MapPole += Pole;
	if (EliminatedBy == "") EliminatedBy = "*";
}

/* ------------------------------------- */
// Update round top
foreach (Player in Players) {
	if (Player.Score != Null && Player.Score.RoundPoints > Top::GetPlayerPoints("Round", Player)) {
		Top::SetPlayerPoints("Round", Player, Player.Score.RoundPoints);
	}
}

/* ------------------------------------- */
// Display the name of the round winner
DisplayWinnerName("Round", RoundWinnerPlayer);
UpdateLayerScoresTable();
CustomSleep(1500);

/* ------------------------------------- */
// Show round results
OffZoneRadius = -1.;
StartTime = -1;
EndTime = -1;
UIManager.UIAll.CountdownEndTime = -1;
SM::UnspawnAllPlayers();
declare ManialinkTops = 
	Top::GetFrameTop2("Survival", _("Top 5 Survival"), "-78 88", "") ^
	Top::GetFrameTop2("Hit", _("Top 5 Hit"), "-26 88", "") ^
	Top::GetFrameTop2("Pole", _("Top 5 Pole"), "26 88", "") ^
	Top::GetFrameTop2("Round", _("Best Round Score"), "78 88", "");
LayerUpdated = Layers::Update("Tops", ManialinkTops);
LayerAttached = Layers::Attach("Tops", NullId);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

CustomSleep(6000);
Score::RoundEnd();
UpdateLayerScoresTable();
CustomSleep(4000);

LayerDetached = Layers::Detach("Tops", NullId);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";

/* ------------------------------------- */
// Map end conditions
declare MaxPoints = 0;
foreach (Score in Scores) {
	if (Score.Points >= MaxPoints) {
		if (Score.Points > MaxPoints) {
			MapWinnerPlayer = Score.User.Id;
		} else if (Score.Points == MaxPoints) {
			MapWinnerPlayer = NullId;
		}
		MaxPoints = Score.Points;
	}
}

declare PointLimitReached = MaxPoints >= S_MapPointsLimit;
declare RequestTieBreak = (!C_AllowDrawMap && MapWinnerPlayer == NullId);
if (PointLimitReached && !RequestTieBreak) MB_StopMap = True;
***


***EndMap***
*** 
XmlRpc.SendCallback("endMap",fixGetRankings());
Score::MatchEnd();
Top::RoundEnd();
Top::MatchEnd();

LayerAttached = Layers::Attach("Tops", NullId);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

/* ------------------------------------- */
// Display the name of the map winner
declare DisplayTime = (S_EndMapChatTime * 1000) / 2;
DisplayWinnerName("Map", MapWinnerPlayer);
UpdateLayerScoresTable();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
CustomSleep(DisplayTime);
UpdateLayerScoresTable();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
CustomSleep(DisplayTime);

LayerDetached = Layers::Detach("Tops", NullId);
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";
***


***EndServer***
***
/* -------------------------------------- */
// Layers destruction
LayerDetached = Layers::DetachAll(NullId);
LayerDestroyed = Layers::Destroy("SpawnQueue");
LayerDestroyed = Layers::Destroy("Info");
LayerDestroyed = Layers::Destroy("TabScoresTable");
LayerDestroyed = Layers::Destroy("AltScoresTable");
LayerDestroyed = Layers::Destroy("Tops");
LayerDestroyed = Layers::Destroy("ScoresInSpawn");
Rules::Destroy();
Layers::Clean();
***


/* ------------------------------------- */
// Functions
/* ------------------------------------- */

/* -------------------------------------- */
/** Custom sleep function
 *
 *	@param	_Duration		The time to spend sleeping in ms
 */
Void CustomSleep(Integer _Duration) {
	declare End = Now + _Duration;
	while(Now < End) {
		yield;
		Message::Loop();
		+++SleepLoop+++
	}
}

/* ------------------------------------- */
/// Let the server sleep until there's enough players to start a game
Void WaitForPlayers() {
	declare Waited = False;
	
	while (!ServerShutdownRequested && !MatchEndRequested && PlayersNbTotal <= 0) {
		Waited = True;
		sleep(1000);
	}
}

/* ------------------------------------- */
/** Display the First Elimination message
 *
 *	@param	_UserId		The Id of the user
 *	@param	_Eliminated	Select the message to display: eliminated or eliminator name
 */
Void DisplayFirstElimMessage(Ident _UserId, Boolean _Eliminated) {
	declare Name = "Bot";
	if (Users.existskey(_UserId)) Name = Users[_UserId].Name;
	declare Message = _("$<%1$> did the first elimination!");
	if (_Eliminated) Message = _("First player eliminated!");
	
	Message::SendBigMessage(
		TextLib::Compose(
			Message,
			Name
		), 									///< Message
		3000,								///< Duration
		4,									///< Priority
		CUIConfig::EUISound::PhaseChange,	///< Sound
		1									///< Sound variant
	);
}

/* ------------------------------------- */
/** Display the name of the round/map winner
 *
 *	@param	_Level			Round or map ?
 *	@param	_WinnerPlayer	Id of the winner user
 */
Void DisplayWinnerName(Text _Level, Ident _WinnerPlayer) {
	if (Users.existskey(_WinnerPlayer)) {
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
		declare Message = "";
		if (_Level == "Round") Message = _("$<%1$> wins the round!");
		else if (_Level == "Map") Message = _("$<%1$> wins the map!");
		UIManager.UIAll.BigMessage = TextLib::Compose(
			Message, 
			Users[_WinnerPlayer].Name
		);
	} else {
		UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
		UIManager.UIAll.BigMessage = _("|Match|Draw");
	}
}

/* ------------------------------------- */
// Update last two eliminations
Void UpdateLastEliminations(CSmScore _Score) {
	declare ScoreId = NullId;
	if (_Score != Null) ScoreId = _Score.Id;
	G_LastEliminations[2] = G_LastEliminations[1];
	G_LastEliminations[1] = ScoreId;
}

/* -------------------------------------- */
/**	Update the scores of a player
 *
 *	@param	_Player 	The player who receive the points
 *	@param	_Score		The score to update
 *	@param	_Points		The number of points to add
 */
Void UpdatePlayerScores(CSmPlayer _Player, Integer _Score, Integer _Points) {
	if (_Player.Score == Null) return;
	
	declare Hit for _Player.Score = 0;
	declare Survival for _Player.Score = 0;
	declare Pole for _Player.Score = 0;
	
	switch (_Score) {
		case C_ScoreHit		: Hit += _Points;
		case C_ScoreSurvival: Survival += _Points;
		case C_ScorePole	: Pole += _Points;
	}
	
	_Player.Score.RoundPoints = Hit + Survival + Pole;
	+++OnPointsUpdate+++
}

/* ------------------------------------- */
/** Generate players list for the score table
 *
 *	@param	_Nb		Number of players in the list
 *	@param	_Scale	Width scale
 *
 *	@return	The players list Text
 */
Text CreatePlayersListSmall(Integer _Nb, Real _Scale) {
	declare ML ="";
	declare PosY = 0.;
	declare S = _Scale;
	
	for (I, 1, _Nb) {
		ML ^= """
<frame posn="0 {{{PosY}}} 1" id="Frame_Player_{{{I}}}">
	<label posn="{{{S*4}}} -3 1" sizen="{{{S*3}}} 3" textsize="1" halign="right" valign="bottom" id="Label_Rank" />
	<label posn="{{{S*4}}} -3 1" sizen="{{{S*32}}} 3" scale="0.7" valign="bottom" id="Label_Name" />
	<label posn="{{{S*33}}} -3 1" sizen="{{{S*8}}} 3" scale="0.7" halign="right" valign="bottom" id="Label_Points" />
</frame>
""";
		PosY -= 4.5;
	}
	
	return ML;
}

/* ------------------------------------- */
/** Generate players list for the score table
 *
 *	@param	_Nb		Number of players in the list
 *	@param	_Scale	Width scale
 *
 *	@return	The players list Text
 */
Text CreatePlayersListBig(Integer _Nb, Real _Scale) {
	declare ML ="";
	declare PosX = 0.;
	declare PosY = 0.;
	declare Col = 2.;
	declare PlayersByCol = MathLib::NearestInteger(_Nb/Col);
	declare S = _Scale;
	declare K = 1;
	
	for (J, 1, 2) {
		for (I, 1, PlayersByCol) {
			ML ^= """
<frame posn="{{{PosX}}} {{{PosY}}} 1" id="Frame_Player_{{{K}}}">
	<quad posn="0 0 1" sizen="10 10" bgcolor="000f" />
	<label posn="5 -5 2" sizen="20 20" scale="0.5" halign="center" valign="center" style="TextRaceMessageBig" text="{{{K}}}" />
	
	<quad posn="10 0 1" sizen="10 10" bgcolor="0003" />
	<quad posn="20 0 1" sizen="{{{58*S}}} 10" bgcolor="{{{C_UI_Colors["BG"]}}}" />
	<label posn="21 -6 2" sizen="{{{115*S}}} 12" scale="0.4" valign="bottom" style="TextRaceMessageBig" />
	<label posn="21 -9 2" sizen="{{{46*S}}} 3" textsize="1" valign="bottom" />
	<label posn="{{{20+56*S}}} -6 2" sizen="{{{10*S}}} 5" textsize="2" halign="right" valign="bottom" />
	<label posn="{{{20+56*S}}} -9 2" sizen="{{{10*S}}} 3" textsize="1.5" halign="right" valign="bottom" />
</frame>
""";
			PosY -= 10.3;
			K += 1;
		}
		PosX += 164*S/2.;
		PosY = 0.;
	}
	
	return ML;
}


/* ------------------------------------- */
/** Generate the score table manialink
 *
 *	@param	_Menu	Alt or Tab menu
 *
 * @return	The manialink Text
 */
Text CreateLayerScoresTable(Integer _Menu) {
	declare ML = "";
	declare PlayersList = "";
	declare FrameName = "Frame_TabScoresTable";
	declare FrameFunction = "";
	
	switch (_Menu) {
		case C_TabMenu: {
			FrameName = "Frame_TabScoresTable";
		}
		case C_AltMenu: {
			FrameName = "Frame_AltScoresTable";
			FrameFunction = """UpdateFrameTab(UI, Page, "ScoresTableTab", "Frame_AltScoresTable");""";
		}
	}
	
	declare CW = 1.;
	declare SW = 1.;
	declare PanelTopNb = 13;
	declare PanelBotNb = 5;
	
	ML = """
<!-- **************** Scores table **************** -->
<quad posn="-156 88" sizen="{{{50*CW}}} 20" halign="left" valign="top" style="TitleLogos" substyle="Title"/>
<frame posn="0 43 10" id ="{{{FrameName}}}">

	<!-- **************** Center panel **************** -->
	<frame posn="0 0 10">
		<quad posn="0 0 0" sizen="{{{164*CW}}} 104" bgcolor="{{{C_UI_Colors["BG"]}}}" halign="center" />
		
		<quad posn="0 0 1" sizen="{{{164*CW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="center" valign="bottom" />
		<quad posn="{{{164*CW/2.}}} 0 1" sizen="0.5 104" bgcolor="{{{C_UI_Colors["Separator"]}}}" />
		<quad posn="0 -104 1" sizen="{{{164*CW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="center" />
		<quad posn="{{{-164*CW/2.}}} 0 1" sizen="0.5 104" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" />
		
		<quad posn="0 -90 2" sizen="{{{162*CW}}} 0.25" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="center" valign="center" />
		
		<!-- **************** Player info **************** -->
		<frame posn="{{{-164*CW/2.}}} -91.5 1" id="Frame_PlayerInfo">
			<quad posn="{{{CW}}} 0 1" sizen="11 11" bgcolor="0003" id="Quad_PI_Avatar" />
			<label posn="{{{13*CW}}} -6 2" sizen="{{{200*CW}}} 12" scale="0.5" valign="bottom" style="TextRaceMessageBig" id="Label_PI_Name" />
			<label posn="{{{163*CW}}} -6 2" sizen="{{{120*CW}}} 14" scale="0.4" halign="right" valign="bottom" style="TextRaceMessageBig" id="Label_PI_Points" />
			<label posn="{{{13*CW}}} -11 2" sizen="{{{50*CW}}} 12" scale="0.4" valign="bottom" style="TextRaceMessageBig" id="Label_PI_Rank" />
			<label posn="{{{163*CW}}} -11 2" sizen="{{{150*CW}}} 6" textsize="2" halign="right" valign="bottom" id="Label_PI_Rankings" />
		</frame>
	</frame>
	
	<!-- **************** Hit panel **************** -->
	<frame posn="-85 0 2">
		<quad posn="0 0 1" sizen="{{{36*SW}}} 67" bgcolor="{{{C_UI_Colors["BG"]}}}" halign="right" />
		
		<quad posn="0 0 1" sizen="{{{36*SW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" valign="bottom" />
		<quad posn="0 0 1" sizen="0.5 67" bgcolor="{{{C_UI_Colors["Separator"]}}}" />
		<quad posn="0 -67 1" sizen="{{{36*SW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" />
		<quad posn="{{{-36*SW}}} 0 1" sizen="0.5 67" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" />
		
		<label posn="{{{-36*SW/2.}}} -7 2" sizen="{{{34*SW}}} 6" textsize="4" textcolor="{{{C_UI_Colors["Text"]}}}" halign="center" valign="bottom" text="$s{{{_("Hits")}}}" />
		<quad posn="{{{-36*SW/2.}}} -7 2" sizen="{{{34*SW}}} 0.25" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="center" valign="center" />
		
		<frame posn="{{{-35*SW}}} -9 3" id="Frame_Hit">
			{{{CreatePlayersListSmall(PanelTopNb, SW)}}}
		</frame>
		<quad posn="{{{2*SW}}} -5.6 3" sizen="{{{40*SW}}} 9" halign="right" style="Bgs1InRace" substyle="BgTitle2" hidden="1" id="Quad_Hit" />
	</frame>
	
	<!-- **************** Pole panel **************** -->
	<frame posn="-85 -69 2">
		<quad posn="0 0 1" sizen="36 31" bgcolor="{{{C_UI_Colors["BG"]}}}" halign="right" />
		
		<quad posn="0 0 1" sizen="{{{36*SW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" valign="bottom" />
		<quad posn="0 0 1" sizen="0.5 31" bgcolor="{{{C_UI_Colors["Separator"]}}}" />
		<quad posn="0 -31 1" sizen="{{{36*SW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" />
		<quad posn="{{{-36*SW}}} 0 1" sizen="0.5 31" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" />
		
		<label posn="{{{-36*SW/2.}}} -7 2" sizen="{{{34*SW}}} 6" textcolor="{{{C_UI_Colors["Text"]}}}" textsize="4" halign="center" valign="bottom" text="$s{{{_("Pole")}}}" />
		<quad posn="{{{-36*SW/2.}}} -7 2" sizen="{{{34*SW}}} 0.25" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="center" valign="center" />
		
		<frame posn="{{{-35*SW}}} -9 3" id="Frame_Pole">
			{{{CreatePlayersListSmall(PanelBotNb, SW)}}}
		</frame>
		<quad posn="{{{2*SW}}} -5.6 3" sizen="{{{40*SW}}} 9" halign="right" style="Bgs1InRace" substyle="BgTitle2" hidden="1" id="Quad_Pole" />
	</frame>
	
	<!-- **************** Survival panel **************** -->
	<frame posn="85 0 2">
		<quad posn="0 0 1" sizen="36 67" bgcolor="{{{C_UI_Colors["BG"]}}}" halign="left" />
		
		<quad posn="0 0 1" sizen="{{{36*SW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" valign="bottom" />
		<quad posn="{{{36*SW}}} 0 1" sizen="0.5 67" bgcolor="{{{C_UI_Colors["Separator"]}}}" />
		<quad posn="0 -67 1" sizen="{{{36*SW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" />
		<quad posn="0 0 1" sizen="0.5 67" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" />
		
		<label posn="{{{36*SW/2.}}} -7 2" sizen="{{{34*SW}}} 6" textcolor="{{{C_UI_Colors["Text"]}}}" textsize="4" halign="center" valign="bottom" text="$s{{{_("Survival")}}}" />
		<quad posn="{{{36*SW/2.}}} -7 2" sizen="{{{34*SW}}} 0.25" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="center" valign="center" />
		
		<frame posn="{{{1*SW}}} -9 3" id="Frame_Survival">
			{{{CreatePlayersListSmall(PanelTopNb, SW)}}}
		</frame>
		<quad posn="{{{-2*SW}}} -5.6 3" sizen="{{{40*SW}}} 9" style="Bgs1InRace" substyle="BgTitle2" hidden="1" id="Quad_Survival" />
	</frame>
	
	<!-- **************** Elimination panel **************** -->
	<frame posn="85 -69 2">
		<quad posn="0 0 1" sizen="36 31" bgcolor="{{{C_UI_Colors["BG"]}}}" halign="left" />
		
		<quad posn="0 0 1" sizen="{{{36*SW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" valign="bottom" />
		<quad posn="{{{36*SW}}} 0 1" sizen="0.5 31" bgcolor="{{{C_UI_Colors["Separator"]}}}" />
		<quad posn="0 -31 1" sizen="{{{36*SW}}} 0.5" bgcolor="{{{C_UI_Colors["Separator"]}}}" />
		<quad posn="0 0 1" sizen="0.5 31" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="right" />
		
		<label posn="{{{36*SW/2.}}} -7 2" sizen="{{{34*SW}}} 6" textcolor="{{{C_UI_Colors["Text"]}}}" textsize="4" halign="center" valign="bottom" text="$s{{{_("Eliminated by")}}}" />
		<quad posn="{{{36*SW/2.}}} -7 2" sizen="{{{34*SW}}} 0.25" bgcolor="{{{C_UI_Colors["Separator"]}}}" halign="center" valign="center" />
		
		<frame posn="{{{36*SW/2.}}} -8 3" id="Frame_Elimination">
			<quad posn="0 -1 1" sizen="15 15" halign="center" bgcolor="0003" id="Quad_Avatar" />
			<label posn="0 -17 2" sizen="{{{32*SW}}} 5" halign="center" text="-" id="Label_Name" />
		</frame>
	</frame>
	
	<!-- **************** Player info **************** -->
	<frame posn="0 -105.5 1" id="Frame_GameInfo">
		<label posn="0 0 1" text="$s{{{_("Points limit")}}}: {{{S_MapPointsLimit}}}" halign="center" id="Label_PointsLimit" />
	</frame>
</frame>
<script><!--
#Include "TextLib" as TextLib

declare CMlFrame 	Frame_PlayerInfo;
declare CMlQuad		Quad_PI_Avatar;
declare CMlLabel 	Label_PI_Name;
declare CMlLabel 	Label_PI_Rank;
declare CMlLabel	Label_PI_Points;
declare CMlLabel	Label_PI_Rankings;
declare CMlFrame	Frame_Ranking;
declare CMlFrame	Frame_Hit;
declare CMlQuad		Quad_Hit;
declare CMlFrame	Frame_Pole;
declare CMlQuad		Quad_Pole;
declare CMlFrame	Frame_Survival;
declare CMlQuad		Quad_Survival;
declare CMlFrame	Frame_Elimination;
declare CMlQuad		Quad_EliminatorAvatar;
declare CMlLabel	Label_EliminatorName;
declare CMlLabel	Label_PointsLimit;

Integer FindRank(Integer _UIPlayerKey, Integer[Integer] _Ranking) {
	declare Rank = 1;
	
	foreach (PlayerKey => Points in _Ranking) {
		if (PlayerKey == _UIPlayerKey) return Rank;
		Rank += 1;
	}
	
	return _Ranking.count + 1;
}

Integer FindUIPlayerKey(Text[Integer] _RankingLogins) {
	declare UIPlayerKey = -1;
	
	// Get the local player
	if (_RankingLogins.exists(LocalUser.Login)) {
		UIPlayerKey = _RankingLogins.keyof(LocalUser.Login);
	}
	// Get the spectated player
	/*else if (IsSpectatorMode && GUIPlayer != Null && _RankingLogins.exists(GUIPlayer.Login)) {
		UIPlayerKey = _RankingLogins.keyof(GUIPlayer.Login);
	}*/
	// Get the best player id
	else {
		foreach (PlayerKey => PlayerLogin in _RankingLogins) {
			UIPlayerKey = PlayerKey;
			break;
		}
	}
	
	return UIPlayerKey;
}

Void UpdatePlayerInfo(
	Integer 			_UIPlayerKey, 
	Ident[Integer]		_PlayerToScore,
	Integer				_RankHit,
	Integer				_RankSurvival,
	Integer				_RankPole,
	Integer[Integer]	_RankingHit,
	Integer[Integer]	_RankingSurvival,
	Integer[Integer]	_RankingPole
) {
	declare PlayerName = "Bot";
	declare Points = "0 + 0 {{{_("point")}}}";
	declare Rankings = "";
	
	if (_PlayerToScore.existskey(_UIPlayerKey)) {
		declare Score <=> Scores[_PlayerToScore[_UIPlayerKey]];
		PlayerName = Score.User.Name;
		if (Score.Points + Score.RoundPoints > 1) {
			Points = TextLib::Compose(
				"{{{_("%1 + %2 points")}}}", 
				TextLib::ToText(Score.Points), 
				TextLib::ToText(Score.RoundPoints)
			);
		} else {
			Points = TextLib::Compose(
				"{{{_("%1 + %2 point")}}}", 
				TextLib::ToText(Score.Points), 
				TextLib::ToText(Score.RoundPoints)
			);
		}
		
		declare RankCount = Scores.count;
		declare HitPoints = 0;
		declare SurvivalPoints = 0;
		declare PolePoints = 0;
		if (_RankingHit.existskey(_UIPlayerKey)) HitPoints = _RankingHit[_UIPlayerKey];
		if (_RankingSurvival.existskey(_UIPlayerKey)) SurvivalPoints = _RankingSurvival[_UIPlayerKey];
		if (_RankingPole.existskey(_UIPlayerKey)) PolePoints = _RankingPole[_UIPlayerKey];
		Rankings = "$s{{{_("Hit")}}}: "^HitPoints^" ("^_RankHit^"/"^RankCount^") | ";
		Rankings ^= "{{{_("Survival")}}}: "^SurvivalPoints^" ("^_RankSurvival^"/"^RankCount^") | ";
		Rankings ^= "{{{_("Pole")}}}: "^PolePoints^" ("^_RankPole^"/"^RankCount^")";
	}
	
	Quad_PI_Avatar.ChangeImageUrl("file://Avatars/"^LocalUser.Login^"/Default");
	Label_PI_Name.SetText(PlayerName);
	Label_PI_Rank.SetText("#"^_UIPlayerKey);
	Label_PI_Points.SetText(Points);
	Label_PI_Rankings.SetText(Rankings);
}

Void UpdatePanel(Text _PanelName, Integer _UIPlayerKey, Integer _Rank, Integer[Integer] _Ranking, Integer _Limit, Ident[Integer] _PlayerToScore) {
	declare CMlFrame 	MainFrame;
	declare CMlQuad		MainQuad;
	switch (_PanelName) {
		case "Hit": { MainFrame <=> Frame_Hit; MainQuad <=> Quad_Hit; }
		case "Survival": { MainFrame <=> Frame_Survival; MainQuad <=> Quad_Survival; }
		case "Pole": { MainFrame <=> Frame_Pole; MainQuad <=> Quad_Pole; }
		default: return;
	}
	
	MainQuad.Hide();
	
	declare PlayerDisplayed = False;
	
	// List players
	declare I = 0;
	foreach (PlayerKey => Points in _Ranking) {
		if (Points <= 0) break;
		
		I += 1;
		declare Frame_Player	<=> (MainFrame.GetFirstChild("Frame_Player_"^I) as CMlFrame);
		declare Label_Rank		<=> (Frame_Player.GetFirstChild("Label_Rank") as CMlLabel);
		declare Label_Name		<=> (Frame_Player.GetFirstChild("Label_Name") as CMlLabel);
		declare Label_Points	<=> (Frame_Player.GetFirstChild("Label_Points") as CMlLabel);
		
		Frame_Player.Show();
		
		declare PlayerName = "Bot";
		if (_PlayerToScore.existskey(PlayerKey)) {
			declare Score <=> Scores[_PlayerToScore[PlayerKey]];
			PlayerName = "$s"^Score.User.Name;
		}
		
		if (PlayerKey == _UIPlayerKey) {
			MainQuad.Show();
			MainQuad.PosnY = Frame_Player.PosnY - 5.6;
			PlayerDisplayed = True;
		}
		
		Label_Rank.SetText("$s"^I^".");
		Label_Name.SetText(PlayerName);
		Label_Points.SetText("$s+"^Points);
		
		if (I >= _Limit) break;
	}
	// Display myself if I'm not in the list
	if (!PlayerDisplayed && I >= _Limit && _Ranking.existskey(_UIPlayerKey)) {
		declare Frame_Player	<=> (MainFrame.GetFirstChild("Frame_Player_"^_Limit) as CMlFrame);
		declare Label_Rank		<=> (Frame_Player.GetFirstChild("Label_Rank") as CMlLabel);
		declare Label_Name		<=> (Frame_Player.GetFirstChild("Label_Name") as CMlLabel);
		declare Label_Points	<=> (Frame_Player.GetFirstChild("Label_Points") as CMlLabel);
		
		declare PlayerName = "Bot";
		if (_PlayerToScore.existskey(_UIPlayerKey)) {
			declare Score <=> Scores[_PlayerToScore[_UIPlayerKey]];
			PlayerName = "$s"^Score.User.Name;
		}
		
		MainQuad.Show();
		MainQuad.PosnY = Frame_Player.PosnY - 5.6;
		PlayerDisplayed = True;
		
		Label_Rank.SetText("$s"^_Rank^".");
		Label_Name.SetText(PlayerName);
		Label_Points.SetText("$s+"^_Ranking[_UIPlayerKey]);
	}
	// Hide the remaining list
	for (J, I + 1, _Limit) {
		declare Frame_Player <=> (MainFrame.GetFirstChild("Frame_Player_"^J) as CMlFrame);		
		Frame_Player.Hide();
	}
}

Void UpdateEliminator(Text _EliminatorLogin, Text _EliminatorName, Text[Integer] _RankingLogins) {
	if (_EliminatorLogin != "" && _EliminatorLogin != "*" && _RankingLogins.exists(_EliminatorLogin)) {
		Quad_EliminatorAvatar.ChangeImageUrl("file://Avatars/"^_EliminatorLogin^"/Default");
	} else {
		Quad_EliminatorAvatar.ChangeImageUrl("");
	}
	Label_EliminatorName.SetText("$s"^_EliminatorName);
}

Void UpdateGameInfo(Integer _PointsLimit) {
	Label_PointsLimit.SetText("$s{{{_("Points limit")}}}: "^_PointsLimit);
}

Void UpdateFrameTab(CUIConfig UI, CMlPage Page, Text TabKey, Text FrameTabId) {
	declare netread Boolean _TabsLib_UseTabs for UI;
	if (! _TabsLib_UseTabs) return;
	
	declare netread Boolean _TabsLib_AlwaysShowScores for UI;
	declare Text _TabsLib_CurrentTab for UI;
	
	//ScoreTableOnlyManialink
	if (! _TabsLib_AlwaysShowScores) {
		declare netread Text _TabsLib_ScoresTableTab for UI;
		// @Test: j'ai comment la ligne en dessous et ajouté la ligne avec AltMenuNoDefaultScores
		//UI.ScoreTableOnlyManialink = (_TabsLib_CurrentTab == _TabsLib_ScoresTableTab);
		UI.AltMenuNoDefaultScores = (_TabsLib_CurrentTab == _TabsLib_ScoresTableTab);
	}
	
	declare MainFrame <=> (Page.GetFirstChild(FrameTabId) as CMlFrame);
	if(MainFrame == Null) return;
	
	if(_TabsLib_CurrentTab == TabKey) {
		MainFrame.Show();
	}
	else {
		MainFrame.Hide();
	}
}

main() {
	Frame_PlayerInfo	<=> (Page.GetFirstChild("Frame_PlayerInfo") as CMlFrame);
	Quad_PI_Avatar		<=> (Frame_PlayerInfo.GetFirstChild("Quad_PI_Avatar") as CMlQuad);
	Label_PI_Name		<=> (Frame_PlayerInfo.GetFirstChild("Label_PI_Name") as CMlLabel);
	Label_PI_Rank		<=> (Frame_PlayerInfo.GetFirstChild("Label_PI_Rank") as CMlLabel);
	Label_PI_Points		<=> (Frame_PlayerInfo.GetFirstChild("Label_PI_Points") as CMlLabel);
	Label_PI_Rankings	<=> (Frame_PlayerInfo.GetFirstChild("Label_PI_Rankings") as CMlLabel);
	Frame_Ranking 		<=> (Page.GetFirstChild("Frame_Ranking") as CMlFrame);
	Frame_Hit			<=> (Page.GetFirstChild("Frame_Hit") as CMlFrame);
	Quad_Hit 			<=> (Page.GetFirstChild("Quad_Hit") as CMlQuad);
	Frame_Pole			<=> (Page.GetFirstChild("Frame_Pole") as CMlFrame);
	Quad_Pole 			<=> (Page.GetFirstChild("Quad_Pole") as CMlQuad);
	Frame_Survival		<=> (Page.GetFirstChild("Frame_Survival") as CMlFrame);
	Quad_Survival 		<=> (Page.GetFirstChild("Quad_Survival") as CMlQuad);
	Frame_Elimination	<=> (Page.GetFirstChild("Frame_Elimination") as CMlFrame);
	Quad_EliminatorAvatar	<=> (Frame_Elimination.GetFirstChild("Quad_Avatar") as CMlQuad);
	Label_EliminatorName	<=> (Frame_Elimination.GetFirstChild("Label_Name") as CMlLabel);
	Label_PointsLimit	<=> (Page.GetFirstChild("Label_PointsLimit") as CMlLabel);

	declare netread Integer 			Net_LayerST_Update for UI;
	declare netread Text[Integer]		Net_LayerST_RankingLogins for UI;
	declare netread Integer[Integer]	Net_LayerST_RankingHit for UI;
	declare netread Integer[Integer]	Net_LayerST_RankingSurvival for UI;
	declare netread Integer[Integer]	Net_LayerST_RankingPole for UI;
	declare netread Text				Net_LayerST_EliminatedBy for UI;
	declare netread Integer				Net_LayerST_PointsLimit for UI;
	
	declare UIPlayerKey = -1;
	declare PlayerToScore = Ident[Integer];
	declare RankingLogins = Text[Integer];
	
	declare RankHit = 1;
	declare RankPole = 1;
	declare RankSurvival = 1;

	declare RankingHit = Integer[Integer];
	declare RankingSurvival = Integer[Integer];
	declare RankingPole = Integer[Integer];
	
	declare EliminatorLogin = "";
	declare EliminatorName = "";
	
	declare LastUpdate = Net_LayerST_Update;
	
	while (True) {
		yield;
		
		{{{FrameFunction}}}
		
		if (LastUpdate != Net_LayerST_Update) {
			LastUpdate = Net_LayerST_Update;
			
			RankingLogins = Net_LayerST_RankingLogins;
			
			UIPlayerKey = FindUIPlayerKey(RankingLogins);
			
			RankingHit = Net_LayerST_RankingHit.sort();
			RankingSurvival = Net_LayerST_RankingSurvival.sort();
			RankingPole = Net_LayerST_RankingPole.sort();
			
			EliminatorLogin = Net_LayerST_EliminatedBy;
			EliminatorName = "-";
			
			declare TmpRankingHit = RankingHit;
			declare TmpRankingSurvival = RankingSurvival;
			declare TmpRankingPole = RankingPole;
			foreach (PlayerKey => Points in TmpRankingHit) RankingHit[PlayerKey] *= -1;
			foreach (PlayerKey => Points in TmpRankingSurvival) RankingSurvival[PlayerKey] *= -1;
			foreach (PlayerKey => Points in TmpRankingPole) RankingPole[PlayerKey] *= -1;
			
			RankHit = FindRank(UIPlayerKey, RankingHit);
			RankSurvival = FindRank(UIPlayerKey, RankingSurvival);
			RankPole = FindRank(UIPlayerKey, RankingPole);
			
			PlayerToScore.clear();
			foreach (Score in Scores) {
				if (RankingLogins.exists(Score.User.Login)) {
					PlayerToScore[RankingLogins.keyof(Score.User.Login)] = Score.Id;
				}
				if (Score.User.Login == EliminatorLogin) EliminatorName = Score.User.Name;
			}
			
			UpdatePlayerInfo(
				UIPlayerKey, PlayerToScore, RankHit, RankSurvival, RankPole, RankingHit, RankingSurvival, RankingPole
			);
			UpdatePanel("Hit"		, UIPlayerKey, RankHit		, RankingHit		, {{{PanelTopNb}}}, PlayerToScore);
			UpdatePanel("Survival"	, UIPlayerKey, RankSurvival	, RankingSurvival	, {{{PanelTopNb}}}, PlayerToScore);
			UpdatePanel("Pole"		, UIPlayerKey, RankPole		, RankingPole		, {{{PanelBotNb}}}, PlayerToScore);
			UpdateEliminator(EliminatorLogin, EliminatorName, RankingLogins);
			UpdateGameInfo(Net_LayerST_PointsLimit);
		}
	}
}
--></script>
""";
	
	return ML;
}

/* ------------------------------------- */
/// Update the Scores Table manialink
Void UpdateLayerScoresTable() {
	declare RankingLogins = Text[Integer];
	declare RankingHit = Integer[Integer];
	declare RankingSurvival = Integer[Integer];
	declare RankingPole = Integer[Integer];
	declare Eliminator = "";
	
	declare I = 1;
	foreach (Score in Scores) {
		declare Hit for Score = 0;
		declare Pole for Score = 0;
		declare Survival for Score = 0;
		declare EliminatedBy for Score = "";
		
		RankingLogins[I] = Score.User.Login;
		if (Hit > 0) RankingHit[I] = Hit * -1;
		if (Survival > 0 && EliminatedBy != "") RankingSurvival[I] = Survival * -1;
		if (Pole > 0) RankingPole[I] = Pole * -1;
		I += 1;
	}
	
	declare PlayersAndSpectators = CSmPlayer[];
	foreach (Player in Players) PlayersAndSpectators.add(Player);
	foreach (Spectator in Spectators) PlayersAndSpectators.add(Spectator);
	foreach (Player in PlayersAndSpectators) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null || Player.Score == Null) continue;
		
		declare EliminatedBy for Player.Score = "";
		
		declare netwrite Integer 			Net_LayerST_Update for UI;
		declare netwrite Text[Integer]		Net_LayerST_RankingLogins for UI;
		declare netwrite Integer[Integer]	Net_LayerST_RankingHit for UI;
		declare netwrite Integer[Integer]	Net_LayerST_RankingSurvival for UI;
		declare netwrite Integer[Integer]	Net_LayerST_RankingPole for UI;
		declare netwrite Text				Net_LayerST_EliminatedBy for UI;
		declare netwrite Integer			Net_LayerST_PointsLimit for UI;
		
		Net_LayerST_Update = Now;
		Net_LayerST_RankingLogins = RankingLogins;
		Net_LayerST_RankingHit = RankingHit;
		Net_LayerST_RankingSurvival = RankingSurvival;
		Net_LayerST_RankingPole = RankingPole;
		Net_LayerST_EliminatedBy = EliminatedBy;
		Net_LayerST_PointsLimit = S_MapPointsLimit;
	}
}

/* ------------------------------------- */
/** Generate the spawn queue manialink
 *
 *	@param	_PlayersSpawnQueue	The players spawn queue
 *
 * @return	The manialink Text
 */
Text UpdateLayerSpawnQueue(Integer[Ident] _PlayersSpawnQueue) {
	declare ML = "";
	declare PlayersList = "";
	declare SpawnQueue = Text[Integer];
	declare J = 1;
	declare Max = 10;
	
	foreach (PlayerId => SpawnOrder in _PlayersSpawnQueue) {
		declare Name = "Player";
		if (Players.existskey(PlayerId)) Name = TextLib::MLEncode(Players[PlayerId].Name);
		SpawnQueue[J] = Name;
		J += 1;
	}
	
	declare Height = 0;
	foreach (I => Name in SpawnQueue) {
		declare LabelText = Name;
		if (I == Max && SpawnQueue.count > Max) {
			//LabelText = TextLib::Compose(_("%1 more ..."), TextLib::ToText(SpawnQueue.count - (Max - 1)));
			LabelText = "$w+"^TextLib::ToText(SpawnQueue.count - (Max - 1));
		}
		PlayersList ^= """
<label posn="0 {{{(I - 1) * -5}}} 0" sizen="28 5" text="$s{{{LabelText}}}" id="Label_Player_{{{I}}}" />
""";
		Height = I;
		if (I >= Max) break;
	}
	
	Height = (Height * 5) + 10;
	
	ML = """
<frame posn="157 -88 1">
	<quad posn="0 0 0" sizen="30 {{{Height}}}" bgcolor="0007" halign="right" valign="bottom"/>
	<label posn="-15 {{{Height-1}}} 1" sizen="30 5" halign="center" text="$s{{{_("Queue")}}}"/>
	<frame posn="-29 {{{Height-8}}} 2">
		{{{PlayersList}}}
	</frame>
</frame>
""";	
	return ML;
}

/* ------------------------------------- */
/** create the info manialink
 *
 *	@return		The manialink string
 */
Text CreateLayerInfo() {
	return """
<label posn="156 -86 1" halign="right" valign="bottom" id="Label_RemainingPlayers" />
<script><!--
	#Include "TextLib" as TextLib
	declare Label_RemainingPlayers <=> (Page.GetFirstChild("Label_RemainingPlayers") as CMlLabel);
	declare netread Integer Net_LayerInfo_RemainingPlayers for UI = 1;
	declare LastRemainingPlayers = 0;
	while (True) {
		yield;
		if (LastRemainingPlayers != Net_LayerInfo_RemainingPlayers) {
			LastRemainingPlayers = Net_LayerInfo_RemainingPlayers;
			Label_RemainingPlayers.SetText(TextLib::Compose("$s{{{_("Remaining players: %1")}}}", TextLib::ToText(LastRemainingPlayers)));
		}
	}
--></script>
""";
}

/* ------------------------------------- */
/** Update the info manialink
 *
 *	@param	_RemainingPlayers	The number of remaining players
 */
Void UpdateLayerInfo(Integer _RemainingPlayers) {
	declare PlayersAndSpectators = CSmPlayer[];
	foreach (Player in Players) PlayersAndSpectators.add(Player);
	foreach (Spectator in Spectators) PlayersAndSpectators.add(Spectator);
	foreach (Player in PlayersAndSpectators) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI == Null) continue;
		
		declare netwrite Integer Net_LayerInfo_RemainingPlayers for UI = 1;
		Net_LayerInfo_RemainingPlayers = _RemainingPlayers;
	}
}

/* ------------------------------------- */
/** Update the Scores in Spawn manialink
 *
 *	@return		The manialink string
 */
Text UpdateLayerScoresInSpawn() {
	declare Top3 = "";
	declare I = 0;
	declare Icons = ["First", "Second", "Third"];
	declare Ranking = Text[Integer];
	declare Scoring = Integer[Integer];
	
	foreach (Score in Scores) {
		Ranking[I] = TextLib::MLEncode(Score.User.Name);
		Scoring[I] = Score.Points;
		I += 1;
		if (I >= 3) break;
	}
	
	foreach (Rank => Name in Ranking) {
		Top3 ^= 
"""
<frame posn="-140 {{{ (Rank * -30) - 14 }}}">
	<quad posn="0 -2 1" sizen="30 30" valign="center" style="Icons64x64_1" substyle="{{{ Icons[Rank] }}}" />
	<label posn="30 0 1" sizen="200 20" textsize="15" valign="center" text="{{{ Name }}}" />
	<label posn="270 0 1" sizen="20 20" textsize="15" halign="right" valign="center" text="{{{ Scoring[Rank] }}}" />
</frame>
""";
	}
	
	return 
"""
<frame posn="0 70">
	<frame posn="0 0">
		<quad posn="0 0" sizen="290 92" halign="center" bgcolor="222c" />
		{{{ Top3 }}}
	</frame>
	<frame posn="0 -95">
		<quad posn="0 0" sizen="290 30" halign="center" bgcolor="222c" />
		<frame posn="-140 -14">
			<label posn="12 0 1" sizen="15 20" scale="2" halign="center" valign="center" style="TextRaceMessageBig" id="Label_Rank" />
			<label posn="30 0 1" sizen="200 20" textsize="15" valign="center" id="Label_Name" />
			<label posn="270 0 1" sizen="20 20" textsize="15" halign="right" valign="center" id="Label_Score" />
		</frame>
	</frame>
</frame>
<script><!--
declare Label_Rank <=> (Page.GetFirstChild("Label_Rank") as CMlLabel);
declare Label_Name <=> (Page.GetFirstChild("Label_Name") as CMlLabel);
declare Label_Score <=> (Page.GetFirstChild("Label_Score") as CMlLabel);
if (InputPlayer != Null) {
	Label_Rank.SetText("$s"^(Scores.keyof(InputPlayer.Score) + 1));
	Label_Name.SetText("$s"^InputPlayer.Name);
	Label_Score.SetText("$s"^InputPlayer.Score.Points);
}
--></script>
""";
}

/* ------------------------------------- */
/** Update the survival score of the remaining players
 *
 *	@param	_PlayersAlive	The remaining players
 */
Void UpdateSurvivalScore(Ident[Ident] _PlayersAlive) {
	G_SurvivalScore += 1;
	
	foreach (PlayerId => ScoreId in _PlayersAlive) {
		if (Players.existskey(PlayerId)) {
			UpdatePlayerScores(Players[PlayerId], C_ScoreSurvival, 1);
			Top::IncrementPlayerPoints("Survival", Players[PlayerId], 1);
		}
	}
}


/* ------------------------------------- */
/** Get the rankings (temporary fix).
 *
 * @return		The rankings
 */
Text fixGetRankings() {
	declare PlayerList = "";
        	foreach (Player in Players) {
        		PlayerList = PlayerList^(Player.Login^":"^Player.Score.Points^";");
	        }
        	foreach (Player in Spectators) {
        		PlayerList = PlayerList^(Player.Login^":"^Player.Score.Points^";");
	        }
  return PlayerList;
}
